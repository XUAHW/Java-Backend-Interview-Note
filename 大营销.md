[TOC]



# 1. 数据库结构

## 1.1 







# 2.功能模块

## 2.1 DCC 动态配置中心

### 2.1.1 请求入口

`http://localhost:8091/api/v1/raffle/dcc/update_config?key=degradeSwitch&value=open`

来自`DCCController.updateConfig`

其中key是要动态配置的节点，value是要设置的状态



### 2.1.2 调用流程

使用zookeeper客户端，更改节点值

`Stat stat = client.setData().forPath(keyPath, value.getBytes(StandardCharsets.UTF_8));`





### 2.1.3 @DCCValue注解

```java
// 用该注解标记要动态配置的字段值
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
@Documented
public @interface DCCValue {

    String value() default "";
}
```



### 2.1.4 初始化动态配置字段值

* `DCCValueBeanFactory`实现了`BeanPostProcessor`接口，重写了`Object i(Object bean, String beanName)`方法，这个方法会在SpringBoot初始化每一个bean后运行

* 该方法检测每个bean中的所有字段是否带有`@DCCValue`注解，获取注解值，如degradeSwitch:close
* 检查Zookeeper中是否存在该配置节点，如果不存在，则将close设置为该字段的值，如果存在节点，则从节点加载值作为该字段的值



### 2.1.5 监听节点值变化并修改变量 

* 在DCCValueBeanFactory的构造函数中，通过`CuratorCache.build() → 创建实例并关联client，curatorCache.start() → 启动监听并注册到框架，client（Spring单例） → 持有CuratorCache引用`，监听器被注册到 Curator 内部事件系统：当 ZooKeeper 节点发生变化时，Curator 会自动触发相应的事件回调
* 检测当前变化是否为节点值改变，如果是，则将该节点对应的bean的被@DCCValue管理的字段设置为新的值



### 2.1.6 总流程图

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809055740524.png" alt="image-20250809055740524" style="zoom:67%;" />





### 2.1.7 重点





## 2.2 装配

### 2.2.1 请求入口

`http://localhost:8091/api/v1/raffle/activity/armory?activityId=100301`

来自`RaffleActivityController.armory`

其中参数为活动ID



### 2.2.2 调用流程

* 活动装配：
  * 1个[key: 活动ID value: 活动信息实体] 
  * 多个[key: 活动次数配置ID value: 活动次数配置实体] 
  * 多个[key: sku编号 value: 库存剩余数量]
* 策略装配：
  * [key: 策略ID(与活动ID一一对应) value: 对应策略的奖品记录] 
  * [key: 策略ID + 奖品ID value: 该策略下某个奖品的剩余库存] 
  * [key: 策略ID value: 抽奖范围值] 
  * [key: 策略ID value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)] 
  * [key: 策略ID value: 所使用的装配算法名]
  * [key: 策略ID_权重积分要求 value: 抽奖范围值] 
  * [key: 策略ID_权重积分要求 value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)]  
  * [key: 策略ID_权重积分要求 value: 所使用的装配算法名]
  * [key: 策略ID value: 策略实体对象]



### 2.2.3 活动装配

* 根据活动id查询所有配了该活动的sku实体
* 对于每个SKU实体，将对应的库存装配进Redis  -  [key: sku编号 value: 库存剩余数量]
* 对于每个SKU实体，将对应的活动配置次数预热  -  [key: 活动次数配置ID value: 活动次数配置实体]
* 预热活动  -  [key: 活动ID value: 活动信息实体]



<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809062958741.png" alt="image-20250809062958741" style="zoom:67%;" />



### 2.2.4 策略装配

* 根据策略ID将该策略下的奖品信息加入缓存  -  [key: 策略ID value: 对应策略的奖品记录]
* 缓存每一个奖品的剩余库存  -  [key: 策略ID + 奖品ID value: 该策略下某个奖品的剩余库存]
* 根据策略ID，查询对应的策略，同时写入缓存  -  [key: 策略ID value: 策略实体对象]
* 默认装配配置[全量抽奖概率]
  * 根据奖品列表的概率中精度最高的值计算抽奖范围,如m = 0.03，精度为2，则返回10^2=100
  * 根据概率值范围选择算法，当概率值范围小于等于阈值时，使用 O(1) 算法，否则使用 O(logN)算法
  *  O(1) 算法
    * 将抽奖范围作为总槽位，按概率装填，比如100个槽位，奖品a的概率为30%，则有30个槽位指向奖品a
    * 将槽位使用Map保存，生成策略奖品概率查找表，并进行缓存
    * [key: 策略ID value: 抽奖范围值]   [key: 策略ID value: 抽奖查找表]   [key: 策略ID value: 所使用的装配算法名]
  * O(logN)算法
    * 遍历奖品列表，将概率值转化为对应区间，如范围是100，则奖品a对应的区间为[1,30]
    * 创建概率范围与奖品ID的映射表，键为存储概率区间(起始值-结束值)的Map，值为奖品ID
    * [key: 策略ID value: 抽奖范围值]   [key: 策略ID value: 抽奖查找表]   [key: 策略ID value: 所使用的装配算法名]
* 权重装配配置
  * 在StraegyRule表中查询配置的权重规则rule_weight的具体值，如10:102,103。   70:106,107
  * 将要传入的奖品列表修改为需要的中奖奖品(即达到N积分后固定抽中某几样奖品)
  * 其余按照默认装配配置的流程进行装配
  * [key: 策略ID_权重积分要求 value: 抽奖范围值]  
  * [key: 策略ID_权重积分要求 value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)]  
  * [key: 策略ID_权重积分要求 value: 所使用的装配算法名]



<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809124929654.png" alt="image-20250809124929654" style="zoom:67%;" />



### 2.2.5 总流程图

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809125406287.png" alt="image-20250809125406287" style="zoom:67%;" />



### 2.2.6 重点

#### 2.2.6.1 讲一讲装配的策略

在项目开始的阶段，为了保证抽奖的高效性，通过**空间换时间**的方式，我们使用**O(1)**的算法进行装配，具体策略是通过奖品的概率值计算抽奖范围，然后将抽奖范围的每个数与其对应的奖品ID用Map存储，然后缓存进Redis，这样抽奖的时间复杂度就是O(1)

随着系统的运行，存在某些概率值极低的奖品，抽奖范围变的很大，然后发现所对应的Key的**内存占用**越来越大，考虑到抽奖活动同时有好多种(参考B站的魔力赏)，每个内存占用如果都很高的话会影响系统的运行，造成堵塞，所以对策略进行改进

具体改进就是设置一个阈值，当抽奖范围小于阈值时，依旧采用之前的策略，因为抽奖范围被限制在了阈值内，所以最高的内存占用也是可控的

当抽奖范围大于阈值时，采用O(LogN)的算法，具体来说就是不将所有值都缓存进Redis，而是只缓存**区间值与对应的奖品**，这种情况下空间复杂度仅为O(K),K为区间的数量，也就是奖品的数量，内存占用很低，同时对于时间复杂度而言可以通过二分的方式进行抽奖，为O(LogN)

在常见环境设置下，参照B站的魔力赏最高价位档的设置，精度最高为小数点后4位，在不更新策略时，内存占用是531216字节，按照b站同时存在的活动数为841个，此时内存占用400MB+，单个key占用约0.5MB，经过优化后单个key占用1.5KB，总占用1.5MB，时间方面在10000个槽位，841个活动的情况下，737ms->1298ms

此时还存在一个问题，就是抽奖范围的计算导致的[**抽奖概率失真**](#2.2.6.1 怎么计算RateRange)问题，通过优化抽奖范围值的计算算法，我们彻底解决了因范围值计算不精确导致的**抽奖概率失真问题**，实现了100%精准的概率还原



#### 2.2.6.2 怎么计算RateRange

在最开始的时候，我们使用对应奖品列表中概率的**最小值小数点后的位数**进行计算，比如0.03，小数点后位数为2位，所以RateRange=10^2=100

随着使用发现，抽奖的概率分布并不是预设定好的，而是存在偏差，研究发现是因为这种算法不完善，应该使用**精度最高的概率值**而不是数值最小的概率值

因为存在这样一种情况，最小值为0.1，但是精度最高值为0.15，RateRange应该为10^2=100而不是10^1=10 ,因为在10的情况下，0.15的所对应的槽位数为0.15*10=1.5，取整后为1，而且总槽位数也会发生改变，导致**抽奖概率失真**，所以采用精度最高的概率值去计算RateRange

对应的，所占的槽位数也会变多，在Map的存储方式下，内存会变大，极端情况下会成为**Redis中的大key**，为了解决这个问题，当抽奖范围大于某个阈值时，我们采用O(LogN)的算法进行装配

通过优化抽奖范围值的计算算法，我们彻底解决了因范围值计算不精确导致的**抽奖概率失真问题**，实现了100%精准的概率还原



#### 2.2.6.3 如何设置合理的阈值

默认设置为10000，根据内存占用动态调整



#### 2.2.6.4 如何实现奖品概率的动态实时调整

**场景**：活动开始后，运营通过配置中心将一等奖权重从 `10` 调整为 `50`，此时有1000并发请求正在执行抽奖逻辑，如何保证新概率立即生效且不影响正在处理的请求？











## 2.3 抽奖

### 2.3.1 请求入口



