[TOC]



# 1. 数据库结构

## 1.1 







# 2. DCC 动态配置中心

## 2.1 请求入口

`http://localhost:8091/api/v1/raffle/dcc/update_config?key=degradeSwitch&value=open`

来自`DCCController.updateConfig`

其中key是要动态配置的节点，value是要设置的状态



## 2.2 调用流程

使用zookeeper客户端，更改节点值

`Stat stat = client.setData().forPath(keyPath, value.getBytes(StandardCharsets.UTF_8));`



## 2.3 @DCCValue注解

```java
// 用该注解标记要动态配置的字段值
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
@Documented
public @interface DCCValue {

    String value() default "";
}
```



## 2.4 初始化动态配置字段值

* `DCCValueBeanFactory`实现了`BeanPostProcessor`接口，重写了`Object i(Object bean, String beanName)`方法，这个方法会在SpringBoot初始化每一个bean后运行

* 该方法检测每个bean中的所有字段是否带有`@DCCValue`注解，获取注解值，如degradeSwitch:close
* 检查Zookeeper中是否存在该配置节点，如果不存在，则将close设置为该字段的值，如果存在节点，则从节点加载值作为该字段的值



## 2.5 监听节点值变化并修改变量 

* 在DCCValueBeanFactory的构造函数中，通过`CuratorCache.build() → 创建实例并关联client，curatorCache.start() → 启动监听并注册到框架，client（Spring单例） → 持有CuratorCache引用`，监听器被注册到 Curator 内部事件系统：当 ZooKeeper 节点发生变化时，Curator 会自动触发相应的事件回调
* 检测当前变化是否为节点值改变，如果是，则将该节点对应的bean的被@DCCValue管理的字段设置为新的值



## 2.6 总流程图

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809055740524.png" alt="image-20250809055740524" style="zoom:67%;" />



## 2.7 重点





# 3. 装配

## 3.1 请求入口

`http://localhost:8091/api/v1/raffle/activity/armory?activityId=100301`

来自`RaffleActivityController.armory`

其中参数为活动ID



## 3.2 调用流程

* 活动装配：
  * 1个[key: 活动ID value: 活动信息实体] 
  * 多个[key: 活动次数配置ID value: 活动次数配置实体] 
  * 多个[key: sku编号 value: 库存剩余数量]
* 策略装配：
  * [key: 策略ID(与活动ID一一对应) value: 对应策略的奖品记录] 
  * [key: 策略ID + 奖品ID value: 该策略下某个奖品的剩余库存] 
  * [key: 策略ID value: 抽奖范围值] 
  * [key: 策略ID value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)] 
  * [key: 策略ID value: 所使用的装配算法名]
  * [key: 策略ID_权重积分要求 value: 抽奖范围值] 
  * [key: 策略ID_权重积分要求 value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)]  
  * [key: 策略ID_权重积分要求 value: 所使用的装配算法名]
  * [key: 策略ID value: 策略实体对象]



## 3.3 活动装配

* 根据活动id查询所有配了该活动的sku实体
* 对于每个SKU实体，将对应的库存装配进Redis  -  [key: sku编号 value: 库存剩余数量]
* 对于每个SKU实体，将对应的活动配置次数预热  -  [key: 活动次数配置ID value: 活动次数配置实体]
* 预热活动  -  [key: 活动ID value: 活动信息实体]



<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809062958741.png" alt="image-20250809062958741" style="zoom:67%;" />



## 3.4 策略装配

* 根据策略ID将该策略下的奖品信息加入缓存  -  [key: 策略ID value: 对应策略的奖品记录]
* 缓存每一个奖品的剩余库存  -  [key: 策略ID + 奖品ID value: 该策略下某个奖品的剩余库存]
* 根据策略ID，查询对应的策略，同时写入缓存  -  [key: 策略ID value: 策略实体对象]
* 默认装配配置[全量抽奖概率]
  * 根据奖品列表的概率中精度最高的值计算抽奖范围,如m = 0.03，精度为2，则返回10^2=100
  * 根据概率值范围选择算法，当概率值范围小于等于阈值时，使用 O(1) 算法，否则使用 O(logN)算法
  *  O(1) 算法
    * 将抽奖范围作为总槽位，按概率装填，比如100个槽位，奖品a的概率为30%，则有30个槽位指向奖品a
    * 将槽位使用Map保存，生成策略奖品概率查找表，并进行缓存
    * [key: 策略ID value: 抽奖范围值]   [key: 策略ID value: 抽奖查找表]   [key: 策略ID value: 所使用的装配算法名]
  * O(logN)算法
    * 遍历奖品列表，将概率值转化为对应区间，如范围是100，则奖品a对应的区间为[1,30]
    * 创建概率范围与奖品ID的映射表，键为存储概率区间(起始值-结束值)的Map，值为奖品ID
    * [key: 策略ID value: 抽奖范围值]   [key: 策略ID value: 抽奖查找表]   [key: 策略ID value: 所使用的装配算法名]
* 权重装配配置
  * 在StraegyRule表中查询配置的权重规则rule_weight的具体值，如10:102,103。   70:106,107
  * 将要传入的奖品列表修改为需要的中奖奖品(即达到N积分后固定抽中某几样奖品)
  * 其余按照默认装配配置的流程进行装配
  * [key: 策略ID_权重积分要求 value: 抽奖范围值]  
  * [key: 策略ID_权重积分要求 value: 抽奖查找表(如果是OLogN算法，则存储的是区间值：奖品ID)]  
  * [key: 策略ID_权重积分要求 value: 所使用的装配算法名]



<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809124929654.png" alt="image-20250809124929654" style="zoom:67%;" />



## 3.5 总流程图

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250809125406287.png" alt="image-20250809125406287" style="zoom:67%;" />



## 3.6 重点

### 3.6.1 讲一讲装配的策略

在项目开始的阶段，为了保证抽奖的高效性，通过**空间换时间**的方式，我们使用**O(1)**的算法进行装配，具体策略是通过奖品的概率值计算抽奖范围，然后将抽奖范围的每个数与其对应的奖品ID用Map存储，然后缓存进Redis，这样抽奖的时间复杂度就是O(1)

随着系统的运行，存在某些概率值极低的奖品，抽奖范围变的很大，然后发现所对应的Key的**内存占用**越来越大，考虑到抽奖活动同时有好多种(参考B站的魔力赏)，每个内存占用如果都很高的话会影响系统的运行，造成堵塞，所以对策略进行改进

具体改进就是设置一个阈值，当抽奖范围小于阈值时，依旧采用之前的策略，因为抽奖范围被限制在了阈值内，所以最高的内存占用也是可控的

当抽奖范围大于阈值时，采用O(LogN)的算法，具体来说就是不将所有值都缓存进Redis，而是只缓存**区间值与对应的奖品**，这种情况下空间复杂度仅为O(K),K为区间的数量，也就是奖品的数量，内存占用很低，同时对于时间复杂度而言可以通过二分的方式进行抽奖，为O(LogN)

在常见环境设置下，参照B站的魔力赏最高价位档的设置，精度最高为小数点后4位，在不更新策略时，内存占用是531216字节，按照b站同时存在的活动数为841个，此时内存占用400MB+，单个key占用约0.5MB，经过优化后单个key占用1.5KB，总占用1.5MB，时间方面在10000个槽位，841个活动的情况下，737ms->1298ms

此时还存在一个问题，就是抽奖范围的计算导致的[**抽奖概率失真**](#2.2.6.1 怎么计算RateRange)问题，通过优化抽奖范围值的计算算法，我们彻底解决了因范围值计算不精确导致的**抽奖概率失真问题**，实现了100%精准的概率还原



### 3.6.2 怎么计算RateRange

在最开始的时候，我们使用对应奖品列表中概率的**最小值小数点后的位数**进行计算，比如0.03，小数点后位数为2位，所以RateRange=10^2=100

随着使用发现，抽奖的概率分布并不是预设定好的，而是存在偏差，研究发现是因为这种算法不完善，应该使用**精度最高的概率值**而不是数值最小的概率值

因为存在这样一种情况，最小值为0.1，但是精度最高值为0.15，RateRange应该为10^2=100而不是10^1=10 ,因为在10的情况下，0.15的所对应的槽位数为0.15*10=1.5，取整后为1，而且总槽位数也会发生改变，导致**抽奖概率失真**，所以采用精度最高的概率值去计算RateRange

对应的，所占的槽位数也会变多，在Map的存储方式下，内存会变大，极端情况下会成为**Redis中的大key**，为了解决这个问题，当抽奖范围大于某个阈值时，我们采用O(LogN)的算法进行装配

通过优化抽奖范围值的计算算法，我们彻底解决了因范围值计算不精确导致的**抽奖概率失真问题**，实现了100%精准的概率还原



### 3.6.3 如何设置合理的阈值

默认设置为10000，根据内存占用动态调整



### 3.6.4 如何实现奖品概率的动态实时调整

**场景**：活动开始后，运营通过配置中心将一等奖权重从 `10` 调整为 `50`，此时有1000并发请求正在执行抽奖逻辑，如何保证新概率立即生效且不影响正在处理的请求？





# 4. 抽奖

## 4.1 请求入口

`http://localhost:8091/api/v1/raffle/activity/draw`

来自`RaffleActivityController.draw`

入参是用户id和活动id



## 4.2 调用流程

### 4.2.1 升降级判断

如果是降级状态，则直接返回降级结果



### 4.2.2 创建抽奖记录

#### 4.2.2.1 校验活动信息

1. 活动是否为开启状态
2. 当前日期是否属于活动有效期内

```java
// 根据活动id查询活动
ActivityEntity activityEntity = activityRepository.queryRaffleActivityByActivityId(activityId);

// 校验；活动状态，如果活动状态不是开启状态，则不能抽奖
if (!ActivityStateVO.open.equals(activityEntity.getState())) {
    log.error("创建活动抽奖单失败，活动状态未开启 activityId:{} state:{}", activityId, activityEntity.getState());
    throw new AppException(ResponseCode.ACTIVITY_STATE_ERROR.getCode(), ResponseCode.ACTIVITY_STATE_ERROR.getInfo());
}
// 校验；活动日期「开始时间 <- 当前时间 -> 结束时间」
if (activityEntity.getBeginDateTime().after(currentDate) || activityEntity.getEndDateTime().before(currentDate)) {
    log.error("创建活动抽奖单失败，活动时间未开始 activityId:{} state:{}", activityId, activityEntity.getState());
    throw new AppException(ResponseCode.ACTIVITY_DATE_ERROR.getCode(), ResponseCode.ACTIVITY_DATE_ERROR.getInfo());
}
```



#### 4.2.2.2 查询未被使用的抽奖活动参与订单记录

* 在user_raffle_order表中查询创建但未使用的订单，即状态为created的订单，如果查询到符合要求的订单，封装结果并返回，未查询到订单，返回null

* 如果存在未被使用的抽奖单表示额度扣除了，但还未进行抽奖，所以直接返回即可，避免多消耗额度

```sql
select user_id, activity_id, activity_name, strategy_id, order_id, order_time, order_state
from user_raffle_order
where user_id = #{userId} and activity_id = #{activityId} and order_state = 'create'
order by create_time desc
limit 1
```



#### 4.2.2.3 账户额度过滤

**查询活动总账户额度**

活动总账户正常情况都存在，因为如果是新用户最开始是没次数的，要签到或者购买次数，此时就会创建活动总账户

所以1.额度不足 2.活动总账户不存在都可以认为是额度不足的异常，因为活动总账户不存在就表示额度为0，此时抛出异常



**查询活动月账户额度**

如果月账户不存在则创建月账户，在内存中(还未写入数据库)，同时将聚合对象CreatePartakeOrderAggregate的isExistAccountMonth设为false

如果存在则不创建，判断月剩余额度是否充足

将月账户对象写入聚合对象中



**查询活动日账户额度**

如果日账户不存在则创建日账户，在内存中(还未写入数据库)，同时将聚合对象CreatePartakeOrderAggregate的isExistAccountDay设为false

如果存在则不创建，判断日剩余额度是否充足

将日账户对象写入聚合对象中



#### 4.2.2.4 构建抽奖活动参与订单对象

```java
// 根据活动ID查询活动信息，并转化为实体返回
ActivityEntity activityEntity = activityRepository.queryRaffleActivityByActivityId(activityId);
// 抽奖订单实体对象
UserRaffleOrderEntity userRaffleOrder = new UserRaffleOrderEntity();
userRaffleOrder.setUserId(userId);
userRaffleOrder.setActivityId(activityId);
userRaffleOrder.setActivityName(activityEntity.getActivityName());
userRaffleOrder.setStrategyId(activityEntity.getStrategyId());
userRaffleOrder.setOrderId(RandomStringUtils.randomNumeric(12));
userRaffleOrder.setOrderTime(currentDate);
userRaffleOrder.setOrderState(UserRaffleOrderStateVO.create);
userRaffleOrder.setEndDateTime(activityEntity.getEndDateTime());
```



#### 4.2.2.5 更新活动账户额度，同时将抽奖订单插入数据库(DB操作)

**更新活动总账户(数据库raffle_activity_account)**

将 "活动总账户**数据库**中(签到或购买次数时创建)" 的总剩余额度，月剩余额度，日剩余额度全部-1



**更新/创建活动月账户(数据库raffle_activity_account_month)**

如果活动月账户存在，则将月账户剩余额度-1

如果活动月账户不存在，将聚合对象中的月账户实体插入**数据库**，总额度和剩余额度都设置为总账户额度中的月总额度，同时更新活动总账户的月剩余额度

```
当新建时，说明此时为本月第一次进行抽奖活动，假设配置是总额度:100 月额度:30 日额度:10
本月第一次时应该将月账户设置为总额30 余额29（因为要减去当前的这次抽奖）
因为在月账户更新前就更新了总账户中的月额度，因为比如2月份的情况是：总剩余额度:97 月剩余额度:27
而不管是否新建，总账户的各个剩余额度都会减1, 即此时情况为：总剩余额度:96 月剩余额度:26
当三月份第一次抽奖时，月账户插入: 总额30 余额29
但是期望的应该是：总剩余额度:96 月剩余额度:29(30-1,表示3月份恢复为30后抽了第一次奖)
所以对总账户再进行一次更新
```



**更新/创建活动日账户(数据库raffle_activity_account_day)**

如果活动日账户存在，则将日账户剩余额度-1

如果活动日账户不存在，将聚合对象中的日账户实体插入**数据库**，总额度和剩余额度都设置为总账户额度中的日总额度，同时更新活动总账户的日剩余额度

详情见 "更新/创建活动月账户(数据库)" 



**将抽奖活动参与订单插入数据库(user_raffle_order)**

```java
// 将抽奖订单插入user_raffle_order表
userRaffleOrderDao.insert(UserRaffleOrderPO.builder()
        .userId(userRaffleOrderEntity.getUserId())
        .activityId(userRaffleOrderEntity.getActivityId())
        .activityName(userRaffleOrderEntity.getActivityName())
        .strategyId(userRaffleOrderEntity.getStrategyId())
        .orderId(userRaffleOrderEntity.getOrderId())
        .orderTime(userRaffleOrderEntity.getOrderTime())
        // 状态为created
        .orderState(userRaffleOrderEntity.getOrderState().getCode())
        .build());
```



#### 4.2.2.6 返回抽奖活动参与订单

```java
UserRaffleOrderEntity orderEntity = raffleActivityPartakeService.createOrder(request.getUserId(), request.getActivityId());
```



### 4.2.3 执行抽奖

#### 4.2.3.1 抽奖前责任链过滤

**根据策略ID查询对应的责任链构建顺序**

```java
// 根据策略ID，查询对应的策略
StrategyEntity strategy = strategyRepository.queryStrategyEntityByStrategyId(strategyId);
// 获得策略对应的ruleModels,注意里面不包含"default"，值为rule_blacklist、rule_weight，这里的顺序是数据库字段的顺序
String[] ruleModels = strategy.ruleModels();
```



**构建责任链**

```java
// 按照配置顺序装填用户配置的责任链；rule_blacklist、rule_weight
ILogicChain logicChain = applicationContext.getBean(ruleModels[0], ILogicChain.class);
ILogicChain current = logicChain;
for (int i = 1; i < ruleModels.length; i++) {
    ILogicChain nextChain = applicationContext.getBean(ruleModels[i], ILogicChain.class);
    current = current.setNext(nextChain);
}
// 责任链的最后装填默认责任链，因为ruleModels中不包含"default"，所以需要单独处理
current.setNext(applicationContext.getBean(LogicModel.RULE_DEFAULT.getCode(), ILogicChain.class));
// 写入map中
strategyChainGroup.put(strategyId, logicChain);
```



**选择抽奖算法**

根据装配抽奖策略时的算法，选择抽奖算法

对于O(1)算法，使用哈希表直接获得奖品id

对于O(LogN)算法，使用二分算法判断所属区间，然后在哈希表中找到对应的奖品id





**流程图**

![image-20250811211255357](/Users/huming/Library/Application Support/typora-user-images/image-20250811211255357.png)



#### 4.2.3.2 责任链结果判断

如果走的不是rule_default默认抽奖，而是黑名单/权重抽奖，则直接返回

如果是权重抽奖，则代表该用户的积分已经很多了，就取消了抽奖次数的限制，所以直接返回抽奖结果即可，不用再进行规则树的过滤

如果是黑名单，也直接返回，无需进行下一步

注意，这一部分的奖品库存都是额外配置的，所以不需要库存校验



#### 4.2.3.3 规则树过滤

相比于责任链过滤，规则树过滤的参数多了一个奖品ID，目的是为了检验该奖品的次数限制/库存限制



**根据策略ID和奖品ID查询策略奖品的rule_models**

例如 tree_lock_3 / tree_luck_award，这个是规则树的tree_id



**根据规则树id查找RuleTreeVO**

根据规则树id查找RuleTreeVO,如果不在redis中则根据数据库重新构建一颗规则树并保存进缓存

RuleTreeVO包含规则树节点，节点中包含以该节点为起点的Line



**将规则树VO传入工厂中以获得决策树引擎**

```java
IDecisionTreeEngine treeEngine = defaultTreeFactory.openLogicTree(ruleTreeVO);
```



**引擎串联规则树节点进行规则处理**

```
✅ 初始状态：
玩家从起点出发 → 对应代码中的 根节点（treeRootRuleNode），根节点也是普通节点的一种
脚下踩着一块地砖 → 这就是 普通节点（RuleTreeNodeVO）

🔍 第一步：找到当前地砖对应的守卫
地砖上写着：“去问问守卫，下一步该往哪走”
系统根据地砖上的标识（ruleKey）→ 找到对应的 决策节点（ILogicTreeNode 实现类）
就像找到了这个地砖里的守卫 👮‍♂️

💬 第二步：和守卫对话（执行逻辑）
守卫问你几个问题（比如：“你有没有足够的积分？”、“抽过几次奖？”）
你回答后，守卫做出判断，并告诉你：
“你可以继续往前走”（返回 ALLOW）
“你不能过去，我给你个奖励赶紧离开吧”（返回 TAKE_OVER）
📌 这就是调用 logic(...) 方法的过程。

🧭 第三步：决定下一个地砖（路径选择）
如果守卫允许你前进，他会指着几条路中的一条说：“走这条路: ALLOW/TAKE_OWER”
系统会根据守卫的回答 + 当前地砖的路线配置（treeNodeLineVOList）→ 找到下一个地砖编号（nextNode）
📌 这对应的是 nextNode(...) 和 decisionLogic(...) 的逻辑。

🔁 第四步：循环进行
再次踩到新的地砖（普通节点）
找到新的守卫（决策节点）
继续对话判断...
直到：
没有/找不到下一个地砖了（流程结束）
或者某个守卫直接接管流程（返回最终结果）
```

流程如上图所示

每次规则树节点处理后都返回一个类型，根据这个类型找到下一个规则树节点



**抽象规则树**

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250811221006706.png" alt="image-20250811221006706" style="zoom:67%;" />



**项目规则树(N次解锁奖品)**

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250811222149988.png" alt="image-20250811222149988" style="zoom:67%;" />



**项目规则树(普通奖品)**

<img src="/Users/huming/Library/Application Support/typora-user-images/image-20250811222654694.png" alt="image-20250811222654694" style="zoom:67%;" />

在rule_stock节点中，如果库存充足，会扣减redis中的库存，然后将扣减信息写入阻塞队列，调用job定时处理队列中的信息，从而更新数据库



### 4.2.4 写入中奖记录(DB操作)

**写入中奖记录表(user_award_record)**

```java
// 写入中奖记录表，初始状态为created
userAwardRecordDao.insert(userAwardRecordPO);
```



**写入任务表(task)**

```java
// 写入任务,初始状态为created
taskDao.insert(taskPO);
```



**修改抽奖订单中的记录状态**

```java
// 将用户抽奖表中的状态改为used
int count = userRaffleOrderDao.updateUserRaffleOrderStateUsed(userRaffleOrderReq);
```



**发送信息到MQ(task)**

```java
try {
    // 发送消息[在事务外执行，如果失败还有任务补偿，即定时扫描任务表中未成功或者创建了很久却还没发送的记录继续发送]
    eventPublisher.publish(taskPO.getTopic(), taskPO.getMessage());
    // 更新数据库记录，task 任务表，task 状态改为created
    taskDao.updateTaskSendMessageCompleted(taskPO);
} catch (Exception e) {
    // 发送失败，更新任务表状态为fail
    taskDao.updateTaskSendMessageFail(taskPO);
}
```



### 4.2.5 发送消息任务补偿(DB操作)

#### 4.2.5.1 定时扫描任务表

```java
// 寻找发送失败的或者还没发送的,还没发送的等一会再发送，即刚进入消息表中的不急着发,因为本身就已经发了一次信息，而这个方法是相当于保底
// 为了避免漏发，如果创建时间已经超过阈值了，且还没更新为completed，则再将其纳入要处理的
List<TaskEntity> taskEntities = taskService.queryNoSendMessageTaskList();
```



#### 4.2.5.2 发送消息到MQ(task)

```java
try {
    // 发送消息
    taskService.sendMessage(taskEntity);
    // 更新任务发送消息完成created
    taskService.updateTaskSendMessageCompleted(taskEntity.getUserId(), taskEntity.getMessageId());
} catch (Exception e) {
    log.error("定时任务，发送MQ消息失败 userId: {} topic: {}", taskEntity.getUserId(), taskEntity.getTopic());
    // 更新任务发送消息失败fail
    taskService.updateTaskSendMessageFail(taskEntity.getUserId(), taskEntity.getMessageId());
}
```



### 4.2.6 消费者处理MQ发奖消息

#### 4.2.6.1 查询奖品Key

```java
// 根据奖品ID查询奖品Key
String awardKey = awardRepository.queryAwardKey(distributeAwardEntity.getAwardId());
```

awardKey是奖品的关键属性，比如随机积分，openai使用次数，openai增加使用模型等等

award_config是相关的配置，比如随机积分的范围，具体的次数，增加的模型有什么gpt3，gpt4



#### 4.2.6.2 获取对应的发奖服务

目前只有随机积分的发奖服务

```java
// 奖品服务(目前只有user_credit_random随机积分的发奖服务)
IDistributeAward distributeAward = distributeAwardMap.get(awardKey);

if (null == distributeAward) {
    log.error("分发奖品，对应的服务不存在。awardKey:{}", awardKey);
    throw new RuntimeException("分发奖品，奖品" + awardKey + "对应的服务不存在");
}

// 发放奖品
distributeAward.giveOutPrizes(distributeAwardEntity);
```



#### 4.2.6.3 执行发奖服务(DB操作)

**更新积分账户(user_credit_account)**

```java
// 更新积分 || 创建积分账户
// 根据用户id查询积分账户，不存在即创建，存在即更新
UserCreditAccountPO userCreditAccountRes = userCreditAccountDao.queryUserCreditAccount(userCreditAccountReq);
if (null == userCreditAccountRes) {
    // 插入用户积分账户
    userCreditAccountDao.insert(userCreditAccountReq);
} else {
    // 更新用户积分账户，将总积分和可用积分都加上更新的值
    userCreditAccountDao.updateAddAmount(userCreditAccountReq);
}
```



**修改中奖记录表的状态(user_award_record)**

```java
// 更新用户中奖记录,将created -> completed
int updateAwardCount = userAwardRecordDao.updateAwardRecordCompletedState(userAwardRecordReq);
```



## 4.3 总流程图

## 4.4 重点

### 4.4.1 讲一讲整个抽奖的逻辑



### 4.4.2 抽到库存不足的奖品怎么处理



### 4.4.3 调用第三方发奖服务失败时如何处理

**场景**：用户抽中京东卡，但调用京东接口返回超时



### 4.4.4 新用户必中奖怎么实现

**什么是新用户**：

* **注册时间窗口**：用户注册时间在**7天内**（可根据业务调整至3~14天），确保覆盖真实新用户

* **行为状态校验**：同时满足 **“无历史支付订单” + “首次参与抽奖”**，避免长期未下单用户钻空子



